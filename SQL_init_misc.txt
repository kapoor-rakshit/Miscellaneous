
/* SCHEMA */
-- In some database system schema represents a part of database or a collection of Tables, and collection of schema is a database.
-- However in MySQL schema is synonym of database. so CREATE SCHEMA is nothing but CREATE DATABASE.




/* USER, GRANTS, REVOKE */
/* CREATE NEW USER */
mysql> CREATE USER 'newusername'@'localhost' IDENTIFIED BY 'password';

/* DELETE USER */
mysql> DROP USER ‘username’@‘localhost’;

-- At this point newuser created has no permissions to do anything with the databases.
-- In fact, even if newuser tries to login (with the password, password), they will not be able to reach the MySQL shell.
-- we need to grant permissions to user for same.

/* PERMISSIONS */
-- ALL PRIVILEGES  allow a MySQL user full access to a designated database (or if no database is selected, global access across the system)
-- CREATE          allows them to create new tables or databases
-- DROP            allows them to them to delete tables or databases
-- DELETE          allows them to delete rows from tables
-- INSERT          allows them to insert rows into tables
-- SELECT          allows them to use the SELECT command to read through databases
-- UPDATE          allow them to update table rows
-- GRANT OPTION    allows them to grant or revoke other users’ privileges

-- Syntax : GRANT type_of_permission,type_of_permission,type_of_permission ON database_name.table_name TO ‘username’@'IP_ADDRESS_OF_MACHINE’;
mysql> GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost';        -- here ALL PRIVILEGES are granted on all databases (*) and on all tables (*)

/* To REVOKE a PERMISSION */
-- Syntax : REVOKE type_of_permission ON database_name.table_name FROM ‘username’@‘localhost’;

/* CHECK GRANTS INFORMATION */
-- default "mysql" DB contain grant information in following tables
-- user             : User accounts, static global privileges, and other nonprivilege columns.
-- db               : Database-level privileges.
-- tables_priv      : Table-level privileges.
-- columns_priv     : Column-level privileges.
-- procs_priv       : Stored procedure and function privileges.
-- password_history : Password change history.




/* VARIABLES */
-- There are mainly 3 types of variables in MySQL:

/* 1 */ (User-defined variables (prefixed with @))
-- To create user-defined SESSION variables, use format @variable_name.
-- The user-defined variables are not case-sensitive. It means that the @id and @ID are the same.
-- A user-defined variable defined by one client is not visible by other clients 
--   ie user-defined variable is session-specific and value is not reinitialized rather retained for operations untill session ends
-- These variables can’t be declared, they are only initialized i.e at time of declaration they should be assigned a value.
-- A user-defined variable can hold single value only. If SELECT statement returns multiple values, variable will take value of last row in result.
-- Syntax : SET @variable_name := value;
mysql> SET @start := 1, @finish := 10;                                                    -- we can use either := or = , but it's still better to have := with variables.
mysql> SELECT @counter;                                                                   -- get value of assigned variable
mysql> SELECT @buyPrice:=buyprice FROM products WHERE buyprice > 95 ORDER BY buyprice;    -- multiple rows in select query ,but one result in variable.

/* 2 */ (Local Variables (no prefix))
-- Local variables needs to be declared using DECLARE before accessing it.
-- Syntax : DECLARE variable_name datatype(size) [DEFAULT default_value];
          : SET variable_name := value;
-- If you declare a variable without specifying a DEFAULT value, its value is NULL.
mysql> DECLARE mystr VARCHAR(255) DEFAULT "default_value";
mysql> DECLARE x,y INT DEFAULT 0;

/* 3 */ (Server System Variables (prefixed with @@))
-- Syntax : SELECT @@var_name;
mysql> SELECT @@sort_buffer_size;




/* IF-ELSEIF-ELSE */
IF(<condition>) THEN
   <statements>;
ELSEIF(<elseif-condition>) THEN
   <elseif-statements>;
ELSE
   <else-statements>;
END IF;




/* CASE statement */
CASE <case_value>
   WHEN <when_value1> THEN <statements>
   WHEN <when_value2> THEN <statements>
   ...
   ELSE <else-statements>
END CASE;




/* LOOP */
<loop_label>: LOOP
    <SQL_statements_if_any>
    IF <condition> THEN
        LEAVE <loop_label>;              -- LEAVE is similar to "break" ie terminate the loop , exit flow control that has given label.
    ELSEIF <condition> THEN
        ITERATE <loop_label>;            -- ITERATE is similar to "continue" , SKIP remaining flow control statements after it that has given label.
    END IF;
    <SQL_statements_if_any>
END LOOP;




/* CURSOR */
/* REFERENCE : https://www.mysqltutorial.org/mysql-cursor */
-- A cursor allows you to iterate a set of rows returned by a query and process each row individually. 
-- Cursors can be used in stored procedures, stored functions, and triggers.
-- Cursor is a Temporary Memory. It is Allocated by Database Server at Time of Performing DML operations on Table by User.
-- MySQL cursor is read-only, non-scrollable and asensitive.
   -- Read-only: you cannot update data in the underlying table through the cursor.
   -- Non-scrollable: you can only fetch rows in the order determined by the SELECT statement. 
                      You cannot fetch rows in the reversed order. In addition, you cannot skip rows or jump to a specific row in the result set.
   -- Asensitive: There are two kinds of cursors: asensitive cursor and insensitive cursor. 
                  An asensitive cursor points to the actual data, whereas an insensitive cursor uses a temporary copy of the data. 
                  An asensitive cursor performs faster than an insensitive cursor because it does not have to make a temporary copy of data. 
                  However, any change that made to the data from other connections will affect the data that is being used by an asensitive cursor, 
                  therefore, it is safer if you do not update the data that is being used by an asensitive cursor.
                  MySQL cursor is asensitive.
-- Declare a cursor
   mysql> DECLARE <cursor_variable> CURSOR FOR <SELECT_statement>;
-- We must also declare a NOT FOUND handler to handle the situation when the cursor could not find any row.
-- handler declaration must appear after variable and cursor declaration.
   mysql> DECLARE <notFoundVar> INTEGER DEFAULT 0;
   mysql> DECLARE CONTINUE HANDLER FOR NOT FOUND SET <notFoundVar> = 1;
-- Open the cursor
   mysql> OPEN <cursor_variable>;
-- Retrieve the next row pointed by the cursor and move the cursor to the next row in the result set
   mysql> FETCH <cursor_variable> INTO <variable>;
-- Deactivate the cursor and release the memory associated with it
   mysql> CLOSE <cursor_variable>;
   
   
   

/* SQL Injection */
/* REFERENCE : https://www.w3schools.com/sql/sql_injection.asp */
-- SQL injection is the placement of malicious code in SQL statements, via web page input.
-- SQL injection is a code injection technique that might destroy your database.
-- SQL injection usually occurs when you ask a user for input, like their username/userid, and instead of a name/id, 
   the user gives you an SQL statement that you will unknowingly run on your database.
-- SQL Injection Based on 1=1 is Always True.
   Following statement got user-id as        105 OR 1=1        from user input and it was run to get access to all the user names and passwords in table.
   mysql> SELECT * FROM Users WHERE UserId = 105 OR 1=1;
-- SQL Injection Based on ""="" is Always True.
   mysql> SELECT * FROM Users WHERE Name ="" or ""="" AND Pass ="" or ""="";
-- SQL Injection Based on Batched SQL Statements
   Following example got user-id as          105; DROP TABLE Suppliers      from user input
   mysql> SELECT * FROM Users WHERE UserId = 105; DROP TABLE Suppliers;
-- Use SQL Parameters for Protection against SQL Injection.
   SQL parameters are values that are added to an SQL query at execution time, in a controlled manner.
   The SQL engine checks each parameter to ensure that it is correct for its column and are treated literally, and not as part of the SQL to be executed.


