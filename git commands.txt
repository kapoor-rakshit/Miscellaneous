
NOTE  :  PLEASE MAKE SURE THAT PATH var is having value for git ((eg:- D:\Git\cmd)) in ACCOUNT or SYSTEM VARIABLES


Create a new repository on GitHub.   (github.com) 
To avoid errors, do not initialize the new repository with README, license, or gitignore files. 
You can add these files after your project has been pushed to GitHub.

Open Git Shell on Windows platform      (can be downloaded from official site)

Change the current working directory to your local project.

Initialize the local directory as a Git repository.
$ git init

Add the files in your new local repository. This stages them for the first commit. Mind the '.'
$ git add .

Commit the files that you've staged in your local repository.
$ git commit -m "First commit"            // -m   :  message

In the Command prompt, add the URL for the remote repository where your local repository will be pushed.
This command will map remote repository at <remote_repo_url> to a ref in your local repo under <remote_name> (eg:- origin)
use the <remote_name> on the command line in lieu of the whole URL.

$ git remote add <--remote_name--> <--remote repository URL-->

Verifies the new remote URL
$ git remote -v

Push the changes in your local repository to GitHub.   eg:- $ git push origin master
$ git push <remote_name> <branch_name>





Adding a file to a repository.
On your computer, move the file you'd like to upload to GitHub into the local directory that was created when you cloned the repository.

Open Git Bash.

Change the current working directory to your local repository.

Stage the file for commit to your local repository. Mind the '.'
$ git add .

Commit the file that you've staged in your local repository.
$ git commit -m "Add existing file"

Push the changes in your local repository to GitHub.
$ git push <remote_name> <branch_name>




GIT IGNORE
# Reference : https://git-scm.com/docs/gitignore


# A gitignore file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected.

# Each line in a gitignore file specifies a pattern. 

# A line starting with # serves as a comment. Put a backslash ("\#") in front of the first hash for patterns that begin with a hash.

# Trailing spaces are ignored unless they are quoted with backslash ("\ ")

# An optional prefix "!" which negates the pattern

# If the pattern ends with a slash, it will find match with directory but NOT match a regular file.

# "*" matches anything except "/"
# "?" matches any one character except "/"
# "[]" matches one character in a selected range

# A leading slash matches the beginning of the pathname.

# A leading "**" followed by a slash means match in all directories
# A trailing "/**" matches everything inside
# A slash followed by two consecutive asterisks then a slash matches zero or more directories

ngproj/reference_screenshots/




Cloning a repository
Change the current working directory to the location where you want the cloned directory to be made.

NOTE : 'git clone' will automatically configure your repo with a remote pointed to the Git URL you cloned it from. 
This means that once you make changes to a file and commit them, you can git push those changes to the remote repository.
'git clone' command implicitly adds the <remote_name> 'origin'

Use git clone
$ git clone <--https://github.com/YOUR-USERNAME/YOUR-REPOSITORY-->

NOTE : Git’s design includes everything in each copy of a repository, every clone gets not only the files but every revision of every
file ever committed. Fortunately, Git supports the notion of a “shallow clone”, which is a more succinctly meaningful way of describing
a local repository with history truncated to a particular depth during the clone operation with "--depth" argument.

$ git clone --depth 1 <--https://github.com/jq/jq.git-->       // clone with a history truncated to the specified number of commits of all branches

Clone only specific BRANCH
$ git clone -b <branch> <remote_repo_URL>                     // clone a branch with history/commits of all branches

$ git clone -b <branch> --single-branch <remote_repo_URL>     // add --single-branch to prevent fetching history/commits of all branches





Working with branches
Each time that you want to commit a bug or a feature, you need to create a branch for it, which will be a copy of your master branch.

Create the branch on your local machine and switch in this branch
This will give you a new branch with the same state as branch currently we are on.
$ git checkout -b [new_branch]
$ git checkout -b [new_branch] [old_branch]                   // new_branch will be copy of old_branch

Change working branch
$ git checkout [name_of_your_new_branch]

Create new branch without switching
$ git branch [new_branch]
$ git branch [new_branch] [old_branch]

Push the branch on github. When you want to commit something in your branch, be sure to be in your branch.
$ git push <remote_name> [name_of_your_new_branch]

see all branches created. (* shows current branch on local machine)
$ git branch

rename a branch
$ git branch -m [old-name] [new-name]          # Rename your local branch
$ git push origin :[old_name]                  # Delete old-name remote branch
$ git push origin -u [new-name]                # Reset the upstream branch for the new-name local branch

Delete a branch on your local filesystem
$ git branch -d [name_of_your_new_branch]

To force the deletion of local branch on your filesystem
$ git branch -D [name_of_your_new_branch]

Delete the branch on github.  Mind the ':' for deletion
$ git push <remote_name> :[name_of_your_new_branch]

shows remote tracking branches that appear in red.
These are read-only copies of the code as it appears on the remote.
Every time we execute git pull or git fetch commands, we update remote tracking branches.
$ git branch --all





Working with remotes
list the shortnames of each remote handle you’ve specified.
If you’ve cloned your repository, you should at least see origin — that is the default name Git gives to the server you cloned from
$ git remote

use param -v which shows you the URLs that Git has stored for the shortname to be used when reading and writing to that remote
$ git remote -v

Inspecting a Remote
$ git remote show <remote_name>

Renaming remote
$ git remote rename <remote_name> <new_remote_name>

Removing remote
$ git remote remove <remote_name>




GIT stash
Git has an area called the stash where you can temporarily store a snapshot of your changes without committing them to the repository.
It’s separate from the working directory, the staging area, or the repository.
This functionality is useful when you’ve made changes to a branch that you aren’t ready to commit,
but you need to switch to another branch.
The command saves your local modifications away and reverts the working directory to match the HEAD commit (latest) for that branch.
$ git stash save "optional message for yourself"

a list of your saved snapshots in the format stash@{ID}: BRANCH-FOR-WHICH-STASHED: MESSAGE
the latest stash made is in the top, id value is {0}
$ git stash list

see a summary of stash made, If you forgot what changes were made in the stash
$ git stash show                               // latest stash, {0}
$ git stash show -p                            // see the typical diff-style patch layout (-p)
                                                  // -What this line looks like on branch
                                                  // +What this line looks like with stashed changes
$ git stash show -p stash@{1}                 // specific stash

apply changes to current branch and leaves a copy in the stash
$ git stash apply                             // latest stash, {0}
$ git stash apply stash@{1}                   // specific stash

creates a new branch with stash, and then deletes the latest stash (like stash pop)
$ git stash branch <branch_name>             // latest stash, {0}
$ git stash branch <branch_name> stash@{1}   // specific stash

applies the changes and removes the files from the stash
$ git stash pop                              // latest stash, {0}
$ git stash pop stash@{1}                    // specific stash

remove stashed changes without applying them
$ git stash drop                            // latest stash, {0}
$ git stash drop stash@{1}                  // specific stash

clear the entire stash
$ git stash clear




GIT fetch
On its own, git fetch updates all the remote tracking branches in local repository
No changes are actually reflected on any of the local working branches
This makes fetching a safe way to review commits before integrating them with your local repository
$ git fetch <remote_name>                       // Fetch all branches, commits, files from <remote_name>
$ git fetch <remote_name> <branch_name>         // Fetch only the specified <branch_name> from <remote_name>
$ git fetch --all                               // Fetch all remotes

Fetched content has to be explicitly checked out using the git checkout command
$ git branch --all                              // check names of remote tracking branch
$ git checkout <remote_name>/<branch_name>      // switch to remote tracking branch, NOTE : use of /

For purposes of reviewing, PRs (Pull Request) in remote should be fetched to the local repo.
ID is the pull request id and BRANCHNAME is the name of the branch that we want to create. 
Once the branch has been created we can switch to that brach.
$ git fetch <remote_name> pull/ID/head:BRANCHNAME




GIT merge
Without any arguments, git merge will merge the corresponding remote tracking branch to the local working branch.
$ git merge
$ git merge <branch_name>                     // merge changes on a seperate branch to current branch




GIT rebase
Rebasing is an alternative to merging. 
Instead of creating a new commit that combines the two branches, it moves the commits of one of the branches on top of the other.

                                             A---B---C        // <branch>
                                           /
                                      D---E---F---G           // <upstream>
				      
All changes made by commits in the current branch but that are not in <upstream> are saved to a temporary area.
The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order.		     

				       A'--B'--C'             // <branch>
                                      /
                         D---E---F---G                        // <upstream>
			 
Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..<upstream> are omitted.
(i.e a patch already accepted upstream with a different commit message or timestamp will be skipped)
(eg: if A and F introduce same set of changes but have different committer information)

                                       B'--C'                 // <branch>
                                      /
                         D---E---F---G                        // <upstream>

$ git rebase <upstream> <branch>      // eg : git rebase master topic
                                      // git checkout <branch> followed by git rebase <upstream>.
				      // When rebase exits, <branch> will remain the checked-out branch.




GIT pull
git pull is a combination command, equal to git fetch + git merge.
If you have uncommitted changes, the merge part of the git pull command will fail and your local branch will be untouched.
Thus, you should always commit your changes in a branch before pulling new commits from a remote repository.

                                            A---B---C    branch on remoteURL
	                                   /
                                      D---E---F---G      branch in local repository
                                      
"git pull" will fetch and replay the changes from the remote branch since it diverged from the local branch (i.e. E) 
until its current commit (C) on top of branch and record the result in a new commit along with the names of the two parent commits (A, B)
and a log message from the user describing the changes.

                                         A---B---C       branch on remoteURL
	                                /         \
                                   D---E---F---G---H     branch in local repository
$ git pull <remote_name> <branch_name>

You can pull using rebase instead of merge.
That takes your commits that are not on the remote version of your branch and 
reworks/rebases them so that they're ahead of (on top of) the new commits you pull in with your pull.
$  git pull --rebase <remote_name> <branch_name>

To set it up so every branch you ever create on any repository is set to pull with rebase
$ git config --global branch.autosetuprebase always

Limit pull to specified commit history
$ git pull --depth 1 <remote_name> <branch_name>




Unstage a file
If you moved a file into the staging area with git add ,  but no longer want it to be part of a commit,
you can use git reset to unstage that file:
$ git reset HEAD <FILE-NAME>




GIT CONFIG
configure username and email with which user want to push commits as The Git username is not the same as GitHub username.
GitHub uses the email address set in local Git configuration to associate commits pushed from the command line with GitHub account.

$ git config --global user.name "kapoor-rakshit"
$ git config --global user.email "email@example.com"      // --global  , setting(s) for every repository on your computer

$ git config user.name "SOPHO"
$ git config user.email "email@example.com"              //              setting(s) for cur dir repo

$ git config --global user.name
$ git config user.name                                  // NO arg passed , check setting(s)

$ git config --global --unset user.name                 // REMOVE key-value from .config file

$ git config --list                                     // Describes the .config file



Log
study repository history using
$ git log                                         //no file name displayed
$ git log --author = <--AUTHOR-->                 //particular author
$ git log --pretty = oneline                     //only commits
$ git log --name-status                          //shows file names changed along with commits



Status
Show the working tree status
Displays paths that have differences between the index file and the current HEAD commit
$ git status
$ git status -v                                 // verbose output
$ git status -s                                 // short-format output

$ git diff                                      // review changes


